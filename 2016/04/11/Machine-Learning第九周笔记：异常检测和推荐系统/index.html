<!DOCTYPE html><html lang="zh-CN"><head><meta http-equiv="content-type" content="text/html; charset=utf-8"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black-translucent" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="description" content="日拱一卒，功不唐捐"><title>Machine Learning第九周笔记：异常检测和推荐系统 | Marcovaldo</title><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/normalize/4.2.0/normalize.min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/pure-min.css"><link rel="stylesheet" type="text/css" href="//cdn.bootcss.com/pure/0.6.0/grids-responsive-min.css"><link rel="stylesheet" type="text/css" href="/css/style.css?v=0.0.0"><link rel="stylesheet" href="//cdn.bootcss.com/font-awesome/4.6.3/css/font-awesome.min.css"><script type="text/javascript" src="//cdn.bootcss.com/jquery/3.0.0/jquery.min.js"></script><link rel="Shortcut Icon" type="image/x-icon" href="/favicon.ico"><link rel="apple-touch-icon" href="/apple-touch-icon.png"><link rel="apple-touch-icon-precomposed" href="/apple-touch-icon.png"></head><body><div class="body_container"><div id="header"><div class="site-name"><h1 class="hidden">Machine Learning第九周笔记：异常检测和推荐系统</h1><a id="logo" href="/.">Marcovaldo</a><p class="description"></p></div><div id="nav-menu"><a href="/." class="current"><i class="fa fa-home"> 首页</i></a><a href="/archives/"><i class="fa fa-archive"> 归档</i></a><a href="/LeetCode/"><i class="fa fa-list"> LeetCode</i></a><a href="/Booklist/"><i class="fa fa-book"> Booklist</i></a><a href="/about/"><i class="fa fa-user"> 关于</i></a></div></div><div id="layout" class="pure-g"><div class="pure-u-1 pure-u-md-3-4"><div class="content_container"><div class="post"><h1 class="post-title">Machine Learning第九周笔记：异常检测和推荐系统</h1><div class="post-meta">Apr 11, 2016<span> | </span><span class="category"><a href="/categories/Machine-Learning/">Machine Learning</a></span><script src="https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js" async></script><span id="busuanzi_container_page_pv"> | <span id="busuanzi_value_page_pv"></span><span> Hits</span></span></div><a data-thread-key="2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" href="/2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/#comments" class="ds-thread-count"></a><div class="clear"><div id="toc" class="toc-article"><div class="toc-title">文章目录</div><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#Anomaly-Detection"><span class="toc-number">1.</span> <span class="toc-text">Anomaly Detection</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Density-Estimation"><span class="toc-number">1.1.</span> <span class="toc-text">Density Estimation</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-Motivation"><span class="toc-number">1.1.1.</span> <span class="toc-text">Problem Motivation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Gaussian-Distribution"><span class="toc-number">1.1.2.</span> <span class="toc-text">Gaussian Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Algorithm"><span class="toc-number">1.1.3.</span> <span class="toc-text">Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Building-an-Anomaly-Detection-System"><span class="toc-number">1.2.</span> <span class="toc-text">Building an Anomaly Detection System</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Developing-and-Evaluating-an-Anomaly-Detection-System"><span class="toc-number">1.2.1.</span> <span class="toc-text">Developing and Evaluating an Anomaly Detection System</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anomaly-Detection-vs-Supervised-Learning"><span class="toc-number">1.2.2.</span> <span class="toc-text">Anomaly Detection vs. Supervised Learning</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Choosing-What-features-to-Use"><span class="toc-number">1.2.3.</span> <span class="toc-text">Choosing What features to Use</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Multivariate-Gaussian-Distribution-Optimal"><span class="toc-number">1.3.</span> <span class="toc-text">Multivariate Gaussian Distribution(Optimal)</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Multivariate-Gaussian-Distribution"><span class="toc-number">1.3.1.</span> <span class="toc-text">Multivariate Gaussian Distribution</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Anomaly-Detection-Using-the-Multivariate-Gaussian-Distribution"><span class="toc-number">1.3.2.</span> <span class="toc-text">Anomaly Detection Using the Multivariate Gaussian Distribution</span></a></li></ol></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#Recommender-Systems"><span class="toc-number">2.</span> <span class="toc-text">Recommender Systems</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#Predicting-Movie-Ratings"><span class="toc-number">2.1.</span> <span class="toc-text">Predicting Movie Ratings</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Problem-Formulation"><span class="toc-number">2.1.1.</span> <span class="toc-text">Problem Formulation</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Content-Based-Recommendations"><span class="toc-number">2.1.2.</span> <span class="toc-text">Content Based Recommendations</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Collaborative-Filtering"><span class="toc-number">2.2.</span> <span class="toc-text">Collaborative Filtering</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Collaborative-Filtering-1"><span class="toc-number">2.2.1.</span> <span class="toc-text">Collaborative Filtering</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Collaborative-Filtering-Algorithm"><span class="toc-number">2.2.2.</span> <span class="toc-text">Collaborative Filtering Algorithm</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Low-Rank-Matrix-Factorization"><span class="toc-number">2.3.</span> <span class="toc-text">Low Rank Matrix Factorization</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Vectorization-Low-Rank-Matrix-Factorization"><span class="toc-number">2.3.1.</span> <span class="toc-text">Vectorization: Low Rank Matrix Factorization</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Implementational-Detail-Mean-Normalization"><span class="toc-number">2.3.2.</span> <span class="toc-text">Implementational Detail: Mean Normalization</span></a></li></ol></li></ol></li></ol></div></div><div class="post-content"><p>Andrew Ng在<em>Machine Learning</em>的第九周介绍了异常检测（anomaly detection）和推荐系统（recommender system），将笔记整理在下面。</p>
<h1 id="Anomaly-Detection"><a href="#Anomaly-Detection" class="headerlink" title="Anomaly Detection"></a>Anomaly Detection</h1><h2 id="Density-Estimation"><a href="#Density-Estimation" class="headerlink" title="Density Estimation"></a>Density Estimation</h2><h3 id="Problem-Motivation"><a href="#Problem-Motivation" class="headerlink" title="Problem Motivation"></a>Problem Motivation</h3><p>视频开头，Andrew Ng告诉我们，异常检测（anomaly detection）主要应用于无监督式学习，但它更像是监督式学习。我们以飞行器发动机为例来介绍异常检测。飞行器发动机会有很多特征，这里我们用$x_1$表示产生的热量，用$x_2$表示振动强度，且假设有数据集{$x^{(1)}$,$x^{(2)}$,...,$x^{(m)}$}（注意，这里的数据是标记的），下图坐标系中每个点代表一组数据。我们的问题是怎样根据现有的这些未标记数据去判断一组新数据是否可靠（如新数据是真实的，还是编造的）。下图中有两组绿色标记的数据点，直观上，我们会觉得上面的那组数据应该更可靠一些，因为该数据点周围有许多其他的数据点；而下面的那组太孤立，可能存在问题。<br><a id="more"></a><br><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__1.png" alt="9_1"></p>
<p>这里我们引入了一个密度估计的模型来判断新数据$x_{test}$异常与否，其中$p(x)$是指数据点在整个数据集中的密度分布，其具体公式会在后面给出。<br>$$p(x_{test}) < \epsilon \xrightarrow{} anomalous$$<br>$$p(x_{test}) \geq \epsilon \xrightarrow{} OK$$<br>对于下图中的training set，我们发现数据点从中心（图中的小圆圈处）到四周（图中的大圆圈处），其密度由大到小。处于中心的数据点其更有可能是正常的，而处于边缘处的数据点则更有可能是异常的。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__2.jpg" alt="9_2"></p>
<p>异常检测的应用有很多，如下图中给出的流量监测中的反作弊、装备制造、监测数据中心的机器运作情况。在前一个应用中，首先提取用户的特征（如用户登录频率、用户访问页面数量、用户的post数量等），收集数据，然后得出密度分布模型$p(x)$，最后用来判断某个用户是否作弊。在后一个应用中，我们可能会提取的特征有内存使用情况、磁盘可用/占用情况、CPU工作量、CPU工作量/流量等等。通过这些特征值，我们可以判断机器运作是否正常。例如，若CPU利用率很高，而流量很小，则该机器可能进入了死循环。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__3.png" alt="9_3"></p>
<h3 id="Gaussian-Distribution"><a href="#Gaussian-Distribution" class="headerlink" title="Gaussian Distribution"></a>Gaussian Distribution</h3><p>这一小节我们介绍Gaussian分布，也就是高中就开始学的正态分布。如果你对Gaussian分布已经相当熟悉的话，就可以跳过这一节了。假设$x \in \mathbb{R}$，如果x服从期望值为$\mu$，方差为$\sigma^2$的Gaussian分布的话，则有<br>$$x \sim N(\mu, \sigma^2)$$<br>$$p(x; \mu, \sigma^2)=\frac{1}{\sqrt{2\pi}\sigma}exp(- \frac{(x-\mu)^2}{2\sigma^2})$$<br>概率密度函数的图像如下图所示</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__4.png" alt="9_4"></p>
<p>下图给出不同参数的Gaussian分布的图像，反映了概率分布函数随数据样本点期望和方差的变化情况。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__5.jpg" alt="9_5"></p>
<p>我们知道概率分布函数中两个参数的定义，对于给定的数据集{${x^{(1)},x^{(2)},…,x^{(m)}}$}，其中$x \in \mathbb{R}$。下面给出计算公式：<br>$$\mu = \frac{1}{m}\sum_{i=1}^{m}x^{(i)}$$<br>$$\sigma^2 = \frac{1}{m}\sum_{i=1}^{m}(x^{(i)-\mu})^2$$</p>
<h3 id="Algorithm"><a href="#Algorithm" class="headerlink" title="Algorithm"></a>Algorithm</h3><p>给定训练数据集{$x^{(1)}$,…,$x^{(m)}$}，其中$x \in \mathbb{R}$，对于x我们有<br>$$p(x) = p(x_1; \mu_1, \sigma_1^2)p(x_2; \mu_2, \sigma_2^2)\cdot ... \cdotp(x_n; \mu_n, \sigma_n^2) = \prod_{i=1}^{n}p(x_i; \mu_i, \sigma_i^2)$$<br>其中$x_i$是x的第i个分量（i的取值是从1到n），且有<br>$$x_i \sim N(\mu_n, \sigma_n^2)$$<br>这就前面提到的密度估计模型。（这里，特征$x_1$到$x_n$是互不相关的）下图给出了具体的密度估计算法：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__6.jpg" alt="9_6"></p>
<p>下图给出了一个具体的应用，特征$x_1$和$x_2$分别服从于$N(\mu_1, \sigma_1^2)$、$N(\mu_2, \sigma_2^2)$的正态分布，二者互不相关。图中标出了两个测试数据$x_{test}^{(1)}$、$x_{test}^{(2)}$，通过计算得知$x_{test}^{(1)}$为正常数据，而$x_{test}^{(2)}$为异常数据。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__7.png" alt="9_7"></p>
<h2 id="Building-an-Anomaly-Detection-System"><a href="#Building-an-Anomaly-Detection-System" class="headerlink" title="Building an Anomaly Detection System"></a>Building an Anomaly Detection System</h2><h3 id="Developing-and-Evaluating-an-Anomaly-Detection-System"><a href="#Developing-and-Evaluating-an-Anomaly-Detection-System" class="headerlink" title="Developing and Evaluating an Anomaly Detection System"></a>Developing and Evaluating an Anomaly Detection System</h3><p>在构建一个学习算法（选择特征等）时， 一个能够衡量学习算法性能的指标会其很大的帮助作用。假设我们有一些已经标记了的数据（正常数据标记为$y=0$，异常数据标记为$y=1$），我么应该让training set中的数据全部为正常数据，cross-validation set和test set中的大部分是正常数据，小部分是异常数据。</p>
<p>下面沿用前面的飞行棋发动机的例子，给出具体的数据分布。注意第二种数据分布中，cross-validation set和test set中的正常数据是一样的，这在很多时候是允许的。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__8.png" alt="9_8"></p>
<p>当然，在处理未标记的数据集时，采用的是同样的一个过程。另外，这里提到了评判学习算法性能的指标，如precision、recall、$F_1 score$，不明白的可以查看第六周笔记二。</p>
<h3 id="Anomaly-Detection-vs-Supervised-Learning"><a href="#Anomaly-Detection-vs-Supervised-Learning" class="headerlink" title="Anomaly Detection vs. Supervised Learning"></a>Anomaly Detection vs. Supervised Learning</h3><p>通过前面的学习，我们发现异常检测和有监督式学习很像，这一节我们就来讨论一下，那些情况适合使用异常检测，那些时候适合有监督式学习。</p>
<p>首先是数据集的分布上有区别：异常检测适用于positive examples（异常数据，y=1）占很少一部分而negative examples（正常数据，y=0）占很大一部分的数据集；而有监督式学习适用于positive examples和negative examples数量相当的数据集。另外，异常检测可以应对多种类型的异常数据，其处理的新的异常数据很可能是以前没有遇到过的（比如，电脑异常中可能会遇到CPU利用率多高、流量过大等多种异常，而这些异常的数量肯定都很低，且必须都能被检测出来）；而监督式学习处理的新数据与training set中的数据是相似的。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__9.png" alt="9_9"></p>
<p>在这里我们结合前面提到的几个应用来对比二者的不同。异常检测的应用有流量监测中的反作弊、装备制造、监测数据中心的机器运作情况等，这里的异常用户/设备（发动机）/电脑相对于正常用户/设备（发动机）/电脑数量很少很少，且种类多样。监督式学习的应用有垃圾邮件系统、天气预测、癌症分类，这几种应用都是讲数据分成数量相当的几类，且同一类中的数据很相似。</p>
<h3 id="Choosing-What-features-to-Use"><a href="#Choosing-What-features-to-Use" class="headerlink" title="Choosing What features to Use"></a>Choosing What features to Use</h3><p>这一小节我们介绍在异常检测中如何设计特征。我们是使用概率密度分布来处理数据，检测异常，因此我们需要是数据集中的特征满足某一分布，如Gaussian分布（当然，你也可以使用其他的分布，这时你就要调整前面的$p(x)$）。下图中左上是一个特征的频率直方图，基本符合Gaussian分布，这时我们可以直接进行异常检测；类似左下这样的明显不符合Gaussian分布，这时我们就需要对其进行调整（图中将$x_1$改成了$log(x_1)$），再进行异常检测。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__10.png" alt="9_10"></p>
<p>通常情况下，在对新数据进行检测时，我们希望由正常数据得到的$p(x)$值很大，而由异常数据得到的$p(x)$值很小，这样就能成功的将二者分开了。但是，有时候却发现，异常数据和正常数据得到的$p(x)$值相当，不能区分开，此时我们就要考虑添加新的特征了。（我的理解是，原有特征对这个异常对敏感，需要增添对此类异常敏感的特征）视频中举了检测电脑运行异常的例子：机器可能出现CPU利用率很高但网络流量很小的情况，原有的特征可能不能检测出这种异常，这时我们要增加类似$x_5$、$x_6$这样的特征，如下图所示。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__11.png" alt="9_11"></p>
<h2 id="Multivariate-Gaussian-Distribution-Optimal"><a href="#Multivariate-Gaussian-Distribution-Optimal" class="headerlink" title="Multivariate Gaussian Distribution(Optimal)"></a>Multivariate Gaussian Distribution(Optimal)</h2><p>下面这两小节都是在介绍多维Gaussian分布，可查阅相关概率书籍。</p>
<h3 id="Multivariate-Gaussian-Distribution"><a href="#Multivariate-Gaussian-Distribution" class="headerlink" title="Multivariate Gaussian Distribution"></a>Multivariate Gaussian Distribution</h3><p>这里使用电脑异常检测的例子，下图左侧给出了数据点在坐标系中的分布情况，其中横坐标$x_1$表示CPU利用率（CPU load），纵坐标$x_2$表示内存占用情况（memory use）。下图右侧给出了$x_1$、$x_2$的频率直方图。我们取坐标系中绿色叉叉对应的数据点x，按照原来的计算方法来检测其是否异常。按照右侧的频率直方图，我们可以发现$p(x_1; \mu_1, \sigma_1^2)$和$p(x_2; \mu_2, \sigma_2^2)$都不会取到太小的值，因此最终的p(x)会取到一个不是很小的值，系统会将其认定为正常数据。但观察左侧坐标系，我们发现$x_1$和$x_2$是正相关的，而绿色叉叉的CPU利用率比较小，内存占用比较大，应该是一个异常数据。很显然，原来的异常检测未能正确判断这组数据。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__12.png" alt="9_12"></p>
<p>发生上面情况的原因是，$x_1$和$x_2$不是相互独立的。此时，我们就应该使用多维正态分布。对于$x \in \mathbb{R}$，我们不再挨个单独计算$p(x_i)$。而是计算下面的公式（搞了半天没写出Latex公式，只好截图(X_X)）：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__17.png" alt="9_17"></p>
<p>下面几张图给出了概率密度函数随参数$\mu$和$\sum$的变化情况，足够我们使用。若有兴趣了解更多，请查阅相关概率论教材。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__13.png" alt="9_13"></p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__14.png" alt="9_14"></p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__15.png" alt="9_15"></p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__16.png" alt="9_16"></p>
<h3 id="Anomaly-Detection-Using-the-Multivariate-Gaussian-Distribution"><a href="#Anomaly-Detection-Using-the-Multivariate-Gaussian-Distribution" class="headerlink" title="Anomaly Detection Using the Multivariate Gaussian Distribution"></a>Anomaly Detection Using the Multivariate Gaussian Distribution</h3><p>给定training set{$x^{(1)},x^{(2)},...,x^{(m)}$}，下图给出计算参数$\mu$和$\sum$的计算公式：<br>$$\mu = \frac{1}{m}\sum_{i=1}^{m}x^{(i)}$$<br>$$\sum = \frac{1}{m}\sum_{i=1}^{m}(x^{(i)} - \mu)(x^{(i)} - \mu)^T$$</p>
<p>使用前面给出的Gaussian分布概率密度函数p(x)来对新数据x进行判断，若$p(x) &lt; \epsilon$，则标记为异常数据。</p>
<p>前面原始模型与多维Gaussian分布模型的区别在于特征的相关性：原始模型中的特征之间是相互独立，其对应于多维Gaussian分布模型中的协方差矩阵$\sum$是一个对角矩阵（即将原始模型的参数放到矩阵中，对角线上是n个特征的方差，其他位置为0）；而多维Gaussian分布的协方差矩阵$\sum$是一个对称矩阵（对角线上是n个特征的方差，而非对角线位置表示的是两两特征之间的相互影响）。<em>想了解更多数学原理的话，请查阅概率论教材。</em></p>
<p>原始模型和多维Gaussian分布模型均可以处理特征不相互独立的问题，差别在于原始模型需要人工去估计两两特征之间的影响，而多维Gaussian分布则自动的量化了两两特征之间的影响。相对应地，前者的计算较简单，后者的计算量增加很多。</p>
<p>当提取到的特征很多，达到了$10^4$及其以上时，我们建议使用传统模型，因为这时${\sum}^{(-1)}$将会有超大的计算量。多维Gaussian分布模型则要求训练数据量m远大于n（视频说起码要$m &gt; 10n$），否则参数$\sum$可能会是不可逆的。</p>
<h1 id="Recommender-Systems"><a href="#Recommender-Systems" class="headerlink" title="Recommender Systems"></a>Recommender Systems</h1><h2 id="Predicting-Movie-Ratings"><a href="#Predicting-Movie-Ratings" class="headerlink" title="Predicting Movie Ratings"></a>Predicting Movie Ratings</h2><h3 id="Problem-Formulation"><a href="#Problem-Formulation" class="headerlink" title="Problem Formulation"></a>Problem Formulation</h3><p>在看到一部电影时，我们通常会去豆瓣上看一下众多网友对该电影的评分情况，然后我们以此来判断要不要看这部电影。这里用到的就是推荐系统（recommender system）机器学习的最大应用之一就是推荐系统，它可以帮助我们更加了解用户，从而提升用户体验，创造更多效益。这里以电影评级预测为例来介绍推荐系统。</p>
<p>下图给出了4个用户对5部电影的评分情况，其中电影分数取值是{1,2,3,4,5}，“？”表示该用户对该电影还未评分。这里引入变量$n_u$、$n_m$分别代表用户和电影的数量，变量$r(i,j)$表示用户j是否对电影i评分（若已评分则$r(i,j)=1$，若未评分则$r(i,j)=0$），变量$y^{(i,j)}$表示用户j对电影i的评分（只有$r(i,j)=0$时才有这一项）。推荐系统要做的就是根据类似这样的数据来预测用户会喜欢那些类型的电影，从而向其推荐。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__18.png" alt="9_18"></p>
<h3 id="Content-Based-Recommendations"><a href="#Content-Based-Recommendations" class="headerlink" title="Content Based Recommendations"></a>Content Based Recommendations</h3><p>如何预测上图中的问号呢，下面给出过程。我们对电影进行特征提取，得到了两个特征$x_1$、$x_2$分别表示电影更倾向于爱情的还是动作的，如下图所示。所以每一部电影都会有一个特征向量$x^{(i)} \in \mathbb{R^3}$，如$x^{(1)}=(1, 0.9, 0)^T$。下面我们要做的是在已有的数据集中为用户j学习到一个参数$\theta^{(j)} \in \mathbb{R^3}$，用$(\theta^{(j)})^Tx^{(i)}$去预测用户j对电影i的评分。如假设系统学习到用户Alice的参数为$\theta^{(1)}=(0, 5, 0)^T$，那么系统预测用户Alice对电影Cute puppies of love的评分为$(\theta^{(1)})^Tx^{(3)}=4.95$。同样地，我们也就可以预测出表中其他问号的值了。</p>
<p>现在我们的问题转换成了线性回归问题，求出其中的参数$\theta^{(j)}$即可，接下来我们要做的就是下面这件事（引入变量$m^{(j)}$表示用户j评价过的电影数量）：<br>$$\min \limits_{\theta^{(j)}}  \frac{1}{2m^{(j)}}\sum_{i:r(i,j)=1}((\theta^{(j)})^T(x^{(i)}) - y^{(i,j)})^2 + \frac{\lambda}{2m^{(j)}}\sum_{k=1}^{n}(\theta_k^{(j)})^2$$<br>其中$\theta^{(j)} \in \mathbb{R^{n+1}}$对于已有的数据集，$m^{(j)}$是一个定值，不会影响到上式，所以我们省去这个变量：<br>$$\min \limits_{\theta^{(j)}}  \frac{1}{2}\sum_{i:r(i,j)=1}((\theta^{(j)})^T(x^{(i)}) - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{k=1}^{n}(\theta_k^{(j)})^2$$</p>
<p>而系统要得到所有的参数$\theta^{(1)}$到$\theta^{(n_u)}$，此时我们要做的是下面这件事（其实就是把所有的$\theta$放一块儿求）：<br>$$\min \limits_{\theta^{(1)},\theta^{(2)},...,\theta^{(n_u)}} \frac{1}{2}\sum_{j=1}^{n_u}\sum_{i:r(i,j)=1}((\theta^{(j)})^T(x^{(i)}) - y^{(i,j)})^2 + \frac{1}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta_k^{(j)})^2$$<br>然后用梯度下降法去修正参数（Latex公式写得实在太累，还是截图吧）：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__19.png" alt="9_19"></p>
<h2 id="Collaborative-Filtering"><a href="#Collaborative-Filtering" class="headerlink" title="Collaborative Filtering"></a>Collaborative Filtering</h2><h3 id="Collaborative-Filtering-1"><a href="#Collaborative-Filtering-1" class="headerlink" title="Collaborative Filtering"></a>Collaborative Filtering</h3><p>前面我们给出了每部的电影的具体特征值，但我们怎么得到这些特征值呢，协同过滤（collaborative filtering）将帮助我们完成这一工作。现在问题变成了求解下图中的所有问号：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__20.png" alt="9_20"></p>
<p>现在假设我们已经得到了参数$\theta^{(1)}$到$\theta^{(4)}$，那我们由$(\theta^{(j)})^Tx^{(i)}=y^{(i,j)}$很容易就可以得到$x^{(1)}$到$x^{(5)}$。</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__21.jpg" alt="9_21"></p>
<p>所以，此时我们要做的是下面这件事：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__22.png" alt="9_22"></p>
<p>现在我们知道了，给定$x^{(1)}$到$x^{(n_m)}$（和电影评分数据集），我们能求得$\theta^{(1)}$到$\theta^{(n_u)}$；而给定$\theta^{(1)}$到$\theta^{(n_u)}$（和评分数据集），我们能求得$x^{(1)}$到$x^{(n_m)}$。现在，我们不妨从一组随机猜测的$\theta^{(j)}$出发去求出一组$x^{(i)}$，再从这组$x^{(i)}$出发求出一组新的$\theta^{(j)}$，如此往复下去，直到我们得到一组令人满意的$\theta^{(j)}$和$x^{(i)}$，这就是协同过滤的基本流程。下一小节，我们将给出具体的算法。</p>
<h3 id="Collaborative-Filtering-Algorithm"><a href="#Collaborative-Filtering-Algorithm" class="headerlink" title="Collaborative Filtering Algorithm"></a>Collaborative Filtering Algorithm</h3><p>前面说了可以从随机的一组$\theta^{(j)}$出发交替求出$x^{(i)}$和$\theta^{(j)}$，直至得到要求。现在我们尝试着同时求出这两组参数，给出下面的这样一个损失函数（用Latex敲出来的公式忒长了，无法显示，只好截图）：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__23.png" alt="9_23"><br><!--$$J(x^{(1)},...,x^{(n_m)},\theta^{(1)},...,\theta^{(n_u)}) = \frac{1}{2}\sum_{(i,j):r(i,j)=1}((\theta^{(j)})Tx^{(i)} - y^{(i,j)})^2 + \frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(i)})^2 + \frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta^{(j)})^2$$--></p>
<p>此时我们的目标就是最小化上面的损失函数：<br>$$\min \limits_{x^{(1)},…,x^{(n_m)} \atop \theta^{(1)},…,\theta^{(n_u)}} J(x^{(1)},…,x^{(n_m)},\theta^{(1)},…,\theta^{(n_u)})$$<br>注意，此时我们省去了线性回归中添加的$x_0$，因此有$x^{(i)} \in \mathbb{R^n}$和$\theta^{(j)} \in \mathbb{R^n}$。</p>
<p>下图是协同过滤算法的详细过程：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__24.png" alt="9_24"></p>
<h2 id="Low-Rank-Matrix-Factorization"><a href="#Low-Rank-Matrix-Factorization" class="headerlink" title="Low Rank Matrix Factorization"></a>Low Rank Matrix Factorization</h2><h3 id="Vectorization-Low-Rank-Matrix-Factorization"><a href="#Vectorization-Low-Rank-Matrix-Factorization" class="headerlink" title="Vectorization: Low Rank Matrix Factorization"></a>Vectorization: Low Rank Matrix Factorization</h3><p>这一小节我们要做的是将数据向量化和矩阵化，如下图：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__25.png" alt="9_25"></p>
<p>前面我们都是在讲如何根据已有评分数据预测用户对某一部电影的喜爱程度，下面我们介绍如何去发现相关电影（finding related movies）。首先，我们需要提取电影的特征，如特征$x_1$代表电影的爱情片系数（值越大，说明该电影越偏向于爱情片），特征$x_2$表示电影的动作片系数，特征$x_3$表示电影的喜剧片系数等等。其实选择是一个很难的事情，现在业界好像还都在“拍脑门”（哎，我觉得这个特征不错，试一把，不成再换）似的提取特征，不过现在很火的深度学习（deep learning）似乎就是在解决这种问题。在选取n个特征之后，其实发现与电影i相关（类型相同等）的电影j就变成了这样一件事：<br>$$small | x^{(i)} - x^{(j)} | \xrightarrow{}  movie　i　and　j　are　similar$$<br>于是，找到上面公式的5个最小值对应的影片，就找到了5部与电影i最相近的影片。</p>
<h3 id="Implementational-Detail-Mean-Normalization"><a href="#Implementational-Detail-Mean-Normalization" class="headerlink" title="Implementational Detail: Mean Normalization"></a>Implementational Detail: Mean Normalization</h3><p>最后一小节讲的是实现推荐系统时要注意的几个细节问题。我们如何去处理一个没有任何评分数据的用户，如Eve呢？我们需要为Eve找到一个参数$\theta^{(5)}$来最小化损失函数。由于Eve没有任何评分记录，所以损失函数的第一部分$\frac{1}{2}\sum \limits_{(i,j):r(i,j)=1}((\theta^{(j)})Tx^{(i)} - y^{(i,j)})^2$为0；而第二部分$\frac{\lambda}{2}\sum_{i=1}^{n_m}\sum_{k=1}^{n}(x_k^{(i)})^2$是对特征参数$x^{(i)}$的求和，是一个常数，对损失函数没有影响；而第三部分$\frac{\lambda}{2}\sum_{j=1}^{n_u}\sum_{k=1}^{n}(\theta^{(j)})^2$与$\theta^{(5)}$相关，要使损失函数得到最小值，只有$\theta^{(5)}$为零向量。所以结论是，推荐系统无法向零数据用户推荐电影，因为实在没有数据参考。</p>
<p>利用均值标准化是求出每个特征的均值，然后用其去处理原始数据，具体如下所示：</p>
<p><img src="http://7xsbsy.com1.z0.glb.clouddn.com/MLAnNote__9__26.png" alt="9_26"></p>
<p>现在我们要从标准化的数据出发去预测，如预测用户j对电影i的评分为$(\theta^{(j)})^T(x^{(i)}) + \mu_i$。对于还没有评分数据的用户Eve，我们初始化其参数$\theta^{(5)}=(0, 0)^T$，我们预测他对电影i的评分为$(\theta^{(5)})^T(x^{(i)}) + \mu_i$。</p>
<p><em>以上就是Machine Learning中的异常检测和推荐系统。</em></p>
</div><script type="text/javascript" src="/js/share.js?v=0.0.0" async></script><a data-url="http://marcovaldong.github.io/2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" data-id="cjfgusk9y0003cgurx2xk18ep" class="article-share-link">分享到</a><div class="tags"><a href="/tags/Machine-Learning/">Machine Learning</a></div><div class="post-nav"><a href="/2016/04/16/Machine-Learning第十周笔记：大规模机器学习/" class="pre">Machine Learning第十周笔记：大规模机器学习</a><a href="/2016/04/09/Machine-Learning第八周笔记：K-means和降维/" class="next">Machine Learning第八周笔记：K means和降维</a></div><div data-thread-key="2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" data-title="Machine Learning第九周笔记：异常检测和推荐系统" data-url="http://marcovaldong.github.io/2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" class="ds-share flat"><div class="ds-share-inline"><ul class="ds-share-icons-16"><li data-toggle="ds-share-icons-more"><a href="javascript:void(0);" class="ds-more">分享到：</a></li><li><a href="javascript:void(0);" data-service="weibo" class="ds-weibo">微博</a></li><li><a href="javascript:void(0);" data-service="qzone" class="ds-qzone">QQ空间</a></li><li><a href="javascript:void(0);" data-service="qqt" class="ds-qqt">腾讯微博</a></li><li><a href="javascript:void(0);" data-service="wechat" class="ds-wechat">微信</a></li></ul><div class="ds-share-icons-more"></div></div></div><div id="container"></div><link rel="stylesheet" href="https://imsun.github.io/gitment/style/default.css"><script src="https://imsun.github.io/gitment/dist/gitment.browser.js"></script><script>var gitment = new Gitment({
  owner: 'marcovaldong',
  repo: 'marcovaldong.github.io',
  oauth: {
    client_id: '3f1a34510c57772de8f8',
    client_secret: '69b8be94d1b53df548e46b9be32356b79e974d3c',
  },
})
gitment.render('container')
</script><div data-thread-key="2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" data-title="Machine Learning第九周笔记：异常检测和推荐系统" data-url="http://marcovaldong.github.io/2016/04/11/Machine-Learning第九周笔记：异常检测和推荐系统/" data-author-key="1" class="ds-thread"></div></div></div></div><div class="pure-u-1-4 hidden_mid_and_down"><div id="sidebar"><div class="widget"><form action="//www.google.com/search" method="get" accept-charset="utf-8" target="_blank" class="search-form"><input type="text" name="q" maxlength="20" placeholder="Search"/><input type="hidden" name="sitesearch" value="http://marcovaldong.github.io"/></form></div><div class="widget"><div class="widget-title"><i class="fa fa-folder-o"> 分类</i></div><ul class="category-list"><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/">Deep Learning</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Deep-Learning/信息隐藏/">信息隐藏</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/">Machine Learning</a><ul class="category-list-child"><li class="category-list-item"><a class="category-list-link" href="/categories/Machine-Learning/Neural-Network/">Neural Network</a></li></ul></li><li class="category-list-item"><a class="category-list-link" href="/categories/爬虫/">爬虫</a></li><li class="category-list-item"><a class="category-list-link" href="/categories/读书/">读书</a></li></ul></div><div class="widget"><div class="widget-title"><i class="fa fa-star-o"> 标签</i></div><div class="tagcloud"><a href="/tags/Deep-Learning/" style="font-size: 15px;">Deep Learning</a> <a href="/tags/Machine-Learning/" style="font-size: 15px;">Machine Learning</a> <a href="/tags/读书/" style="font-size: 15px;">读书</a> <a href="/tags/爬虫/" style="font-size: 15px;">爬虫</a> <a href="/tags/Python/" style="font-size: 15px;">Python</a> <a href="/tags/Theano/" style="font-size: 15px;">Theano</a> <a href="/tags/Tensorflow/" style="font-size: 15px;">Tensorflow</a> <a href="/tags/Kaggle/" style="font-size: 15px;">Kaggle</a> <a href="/tags/机器学习/" style="font-size: 15px;">机器学习</a> <a href="/tags/信息隐藏/" style="font-size: 15px;">信息隐藏</a> <a href="/tags/Steganography/" style="font-size: 15px;">Steganography</a> <a href="/tags/语义分割/" style="font-size: 15px;">语义分割</a> <a href="/tags/面经/" style="font-size: 15px;">面经</a> <a href="/tags/Neural-Network/" style="font-size: 15px;">Neural Network</a> <a href="/tags/机器学习基石/" style="font-size: 15px;">机器学习基石</a> <a href="/tags/steganalysis/" style="font-size: 15px;">steganalysis</a> <a href="/tags/Pose-Estimation/" style="font-size: 15px;">Pose Estimation</a></div></div><div class="widget"><div class="widget-title"><i class="fa fa-file-o"> 最新文章</i></div><ul class="post-list"><li class="post-list-item"><a class="post-list-link" href="/2018/04/01/My-reading-list2/">My reading list</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/03/27/小米面经/">小米面经</a></li><li class="post-list-item"><a class="post-list-link" href="/2018/01/10/关于sematic-segmentation的几篇论文（二）/">关于sematic segmentation的几篇论文（二）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/论文阅读：RealTime-Multi-Person-2D-Pose-Estimation-using-Part-Affinity-Fields/">论文阅读：RealTime Multi-Person 2D Pose Estimation using Part Affinity Fields</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/31/关于semantic-segmentation的几篇论文/">关于semantic segmentation的几篇论文</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/12/06/于众目睽睽之下隐藏图像：深度隐写术/">于众目睽睽之下隐藏图像：深度隐写术</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/08/深度学习在信息隐藏中的应用（下）/">深度学习在信息隐藏中的应用（下）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/11/06/深度学习在信息隐藏中的应用（上）/">深度学习在信息隐藏中的应用（上）</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/05/14/使用Tensorflow实现Titanic比赛/">使用Tensorflow实现Titanic比赛</a></li><li class="post-list-item"><a class="post-list-link" href="/2017/02/19/Python爬虫小结之Selenium/">Python爬虫小结之Selenium</a></li></ul></div><div class="widget"><div class="comments-title"><i class="fa fa-comment-o"> 最近评论</i></div><div data-num-items="5" data-show-avatars="0" data-show-time="1" data-show-admin="0" data-excerpt-length="32" data-show-title="1" class="ds-recent-comments"></div></div><div class="widget"><div class="widget-title"><i class="fa fa-external-link"> 友情链接</i></div><ul></ul><a href="http://killersdeath.github.io" title="抄作业的小东" target="_blank">抄作业的小东</a></div></div></div><div class="pure-u-1 pure-u-md-3-4"><div id="footer">© <a href="/." rel="nofollow">Marcovaldo.</a> Powered by<a rel="nofollow" target="_blank" href="https://hexo.io"> Hexo.</a><a rel="nofollow" target="_blank" href="https://github.com/tufu9441/maupassant-hexo"> Theme</a> by<a rel="nofollow" target="_blank" href="https://github.com/pagecho"> Cho.</a></div></div></div><a id="rocket" href="#top" class="show"></a><script type="text/javascript" src="/js/totop.js?v=0.0.0" async></script><script type="text/javascript" src="//cdn.bootcss.com/fancybox/2.1.5/jquery.fancybox.pack.js" async></script><script type="text/javascript" src="/js/fancybox.js?v=0.0.0" async></script><link rel="stylesheet" type="text/css" href="/css/jquery.fancybox.css?v=0.0.0"><script>var duoshuoQuery = {short_name:'marcovaldo'};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0]
        || document.getElementsByTagName('body')[0]).appendChild(ds);
})();
</script><script>var _hmt = _hmt || [];
(function() {
  var hm = document.createElement("script");
  hm.src = "//hm.baidu.com/hm.js?2be92f134440f46356c71aa55035a144";
  var s = document.getElementsByTagName("script")[0];
  s.parentNode.insertBefore(hm, s);
  })();
</script><script type="text/x-mathjax-config">MathJax.Hub.Config({
  tex2jax: {inlineMath: [['$','$'], ['\\(','\\)']]}
  });
</script><script type="text/javascript" src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-MML-AM_CHTML" async></script><script type="text/javascript" src="/js/codeblock-resizer.js?v=0.0.0"></script><script type="text/javascript" src="/js/smartresize.js?v=0.0.0"></script></div></body></html>